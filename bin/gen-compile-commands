#!/usr/bin/env bash
# gen-compile-commands - Generate compile_commands.json for C/C++ projects
# Usage: gen-compile-commands [OPTIONS] [DIRECTORY]

set -euo pipefail

VERSION="1.0.0"
VERBOSE=false
COMPILER="clang"
OUTPUT_FILE="compile_commands.json"
USE_CACHE=false
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/gen-compile-commands"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    cat <<EOF
Usage: gen-compile-commands [OPTIONS] [DIRECTORY]

Generate compile_commands.json for clangd LSP support.

Options:
  -h, --help       Show this help message
  -v, --verbose    Show detailed output
  -c, --compiler   Specify compiler (default: clang)
  -o, --output     Output file name (default: compile_commands.json)
  --cache          Enable cache (skip if unchanged)
  --version        Show version

Examples:
  gen-compile-commands                 # Generate in current directory
  gen-compile-commands /path/to/proj   # Generate for specific project
  gen-compile-commands -v              # Verbose output
  gen-compile-commands --cache         # Use cache mechanism
EOF
}

log_info() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[INFO]${NC} $1" >&2
    fi
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# A4: Check if cache is valid
check_cache() {
    local project_dir="$1"
    local output_file="$2"
    local cache_file="${CACHE_DIR}/$(echo "$project_dir" | md5sum | cut -d' ' -f1).timestamp"

    if [[ ! -f "$cache_file" ]] || [[ ! -f "$output_file" ]]; then
        log_info "Cache miss: no cache file or output file"
        return 1  # Need regeneration
    fi

    local cache_time
    cache_time=$(cat "$cache_file")

    # Check if any source or header files changed
    local newest_file
    newest_file=$(find "$project_dir" -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" -o -name "*.h" \) -printf '%T@\n' 2>/dev/null | sort -rn | head -1)

    if [[ -z "$newest_file" ]]; then
        log_info "Cache miss: no source files found"
        return 1
    fi

    if (( $(echo "$newest_file > $cache_time" | bc -l 2>/dev/null || echo "1") )); then
        log_info "Cache miss: files modified since last generation"
        return 1  # Changed
    fi

    log_info "Cache hit: using existing compile_commands.json"
    return 0  # Cache valid
}

# A4: Save cache timestamp
save_cache() {
    local project_dir="$1"
    local cache_file="${CACHE_DIR}/$(echo "$project_dir" | md5sum | cut -d' ' -f1).timestamp"

    mkdir -p "$CACHE_DIR"
    date +%s.%N > "$cache_file"
    log_info "Cache saved"
}

# Build JSON arguments array from include flags
build_arguments_json() {
    local compiler="$1"
    local file="$2"
    shift 2
    local include_dirs=("$@")

    local args="\"${compiler}\", \"-c\""
    for dir in "${include_dirs[@]}"; do
        if [[ -n "$dir" ]]; then
            args+=", \"-I${dir}\""
        fi
    done
    args+=", \"${file}\""
    echo "$args"
}

# Generate compile_commands.json
generate_compile_commands() {
    local project_dir="$1"
    local output_path="${project_dir}/${OUTPUT_FILE}"
    local -a include_dirs=()
    declare -A seen_dirs  # A3: Use associative array for O(1) lookup
    local file_count=0
    local first=true

    # Resolve to absolute path
    project_dir="$(cd "$project_dir" && pwd)"

    # A4: Check cache if enabled
    if [[ "$USE_CACHE" == true ]] && check_cache "$project_dir" "$output_path"; then
        log_success "Using cached compile_commands.json (no changes detected)"
        return 0
    fi

    log_info "Scanning directory: ${project_dir}"

    # Find include directories
    local patterns=("include" "inc" "src" "lib" "source" "headers")
    for pattern in "${patterns[@]}"; do
        if [[ -d "${project_dir}/${pattern}" ]]; then
            local dir_path="${project_dir}/${pattern}"
            if [[ -z "${seen_dirs[$dir_path]:-}" ]]; then
                include_dirs+=("$dir_path")
                seen_dirs["$dir_path"]=1
                log_info "Found include dir: ${pattern}/"
            fi
        fi
    done

    # Add project root
    if [[ -z "${seen_dirs[$project_dir]:-}" ]]; then
        include_dirs+=("$project_dir")
        seen_dirs["$project_dir"]=1
    fi

    # A2+A3+A5: Optimized header directory scanning with exclusions
    while IFS= read -r dir; do
        if [[ -n "$dir" && -z "${seen_dirs[$dir]:-}" ]]; then
            seen_dirs["$dir"]=1
            include_dirs+=("$dir")
            log_info "Found header dir: ${dir#$project_dir/}/"
        fi
    done < <(find "$project_dir" -type f -name "*.h" \
        -not -path "*/.git/*" \
        -not -path "*/node_modules/*" \
        -not -path "*/venv*/*" \
        -not -path "*/.venv*/*" \
        -not -path "*/env/*" \
        -not -path "*/build/*" \
        -not -path "*/dist/*" \
        -not -path "*/out/*" \
        -not -path "*/third_party/*" \
        -not -path "*/vendor/*" \
        -not -path "*/external/*" \
        -not -path "*/__pycache__/*" \
        -not -path "*/.tox/*" \
        -not -path "*/.pytest_cache/*" \
        -printf '%h\n' 2>/dev/null | sort -u)

    log_info "Found ${#include_dirs[@]} include directories"

    # A1+A6: Pre-build include flags to avoid repeated string concatenation
    local include_flags=""
    for dir in "${include_dirs[@]}"; do
        if [[ -n "$dir" ]]; then
            include_flags+=", \"-I${dir}\""
        fi
    done

    # A1 (Modified): Batched write to avoid buffer overflow on large projects
    local BATCH_SIZE=100
    declare -a json_batch=()
    local batch_count=0
    local is_first_entry=true

    # Start JSON array
    echo "[" > "$output_path"

    # Find all .c and .cpp files
    while IFS= read -r -d '' file; do
        local rel_file="${file#$project_dir/}"
        local args_json="\"${COMPILER}\", \"-c\"${include_flags}, \"${file}\""

        # Build JSON entry
        local json_entry
        json_entry=$(cat <<EOF
  {
    "directory": "${project_dir}",
    "file": "${file}",
    "arguments": [${args_json}]
  }
EOF
)

        # Add to batch
        json_batch+=("$json_entry")
        ((batch_count++)) || true
        ((file_count++)) || true
        log_info "Added: ${rel_file}"

        # Write batch when it reaches BATCH_SIZE
        if [[ $batch_count -ge $BATCH_SIZE ]]; then
            for entry in "${json_batch[@]}"; do
                if [[ "$is_first_entry" == true ]]; then
                    printf '%s' "$entry" >> "$output_path"
                    is_first_entry=false
                else
                    printf ',\n%s' "$entry" >> "$output_path"
                fi
            done
            json_batch=()
            batch_count=0
        fi
    done < <(find "$project_dir" -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) -print0 2>/dev/null)

    # Write remaining entries in the last batch
    if [[ ${#json_batch[@]} -gt 0 ]]; then
        for entry in "${json_batch[@]}"; do
            if [[ "$is_first_entry" == true ]]; then
                printf '%s' "$entry" >> "$output_path"
                is_first_entry=false
            else
                printf ',\n%s' "$entry" >> "$output_path"
            fi
        done
    fi

    # Close JSON array
    echo "" >> "$output_path"
    echo "]" >> "$output_path"

    if [[ $file_count -eq 0 ]]; then
        log_warn "No C/C++ source files found in ${project_dir}"
        rm -f "$output_path"
        return 1
    fi

    # A4: Save cache if enabled
    if [[ "$USE_CACHE" == true ]]; then
        save_cache "$project_dir"
    fi

    log_success "Generated ${OUTPUT_FILE} with ${file_count} file(s)"
    log_success "Location: ${output_path}"
}

# Parse arguments
PROJECT_DIR="."

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -c|--compiler)
            COMPILER="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --cache)
            USE_CACHE=true
            shift
            ;;
        --version)
            echo "gen-compile-commands v${VERSION}"
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            PROJECT_DIR="$1"
            shift
            ;;
    esac
done

# Validate directory
if [[ ! -d "$PROJECT_DIR" ]]; then
    log_error "Directory not found: ${PROJECT_DIR}"
    exit 1
fi

# Run
generate_compile_commands "$PROJECT_DIR"
